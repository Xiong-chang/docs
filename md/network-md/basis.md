# 网络基础

## OSI七层模型

 ![这是图片](/image/OSI.png "OSI模型")

 - `物理层`：
    就是物理介质方面硬件设施，如：网卡网线，集线器，中继器，调制解调器，物理层信道，传输的是比特流 单位 bit 
- `数据链路层`：
    建立逻辑连接，硬件地址寻址，差错校验等，（由底层网络定义协议）将比特组合成字节进而组合成帧，用 MAC 地址访问介质（MAC地址是乜咯网卡的唯一标识），通过广播的方式进行传输，局域网内所有计算机都能收到，（将数据帧拼接上MAC地址，用交换机跳点的方式进行交互）
- `网络层`：
    定义IP（网络地址），通过路由器端对端寻址，IP协议（IPV4,IPV6）
- `传输层`：
    定义端口号，控流校验，两个一协议 TCP（会进行三次握手四次挥手，可靠性高但会降低速度）， UDP（没有三握四挥效率更高，不稳定但速度快，常用于直播、游戏），这一层经常被叫数据段
- `会话层`：
    报文，就是在发送方和接收方进行通讯时进行创建、维持终止或断开连接的地方，定义了一种机制，允许发送方接收方启动或停止请求会话，双方拥塞时仍能保持对话，使用检查点（checkpoint）机制来维持可靠会话，定义了一个最接近成功通信的点以及当内容丢失或损坏时需要回滚的点，即断点下载的原理
- `表示层`：
    翻译官，安全（数据发送前加密，接受者的表示层解密），压缩（对图片等文件格式进行编码解码如JPEG,ASCII）（报文）
- `应用层`:
    用的最多的一层（如ajax，DNS，邮件协议SMTP，WebSocket长连接，SSH协议），（报文）

## 三次握手（建立连接）

1. 客户端 ---> 服务端 (发送SYN=1建立连接，生成seq序列号（序列号是随机生成的，方便报文整理 ）)（TCP连接请求报文段）（进入同步已发送状态）
2. 服务端 ---> 客户端 （带上第一次发送来的SYN=1外加ACK=1表示是一个连接请求确认报文段，将第一次seq+1生成ack，生成服务端的seq，确认将这些都返回给客户端）（TCP连接请求确认报文段）（进入同步已接收状态）
3. 客户端 ---> 服务端 （发送ACK=1 表明是普通TCP确认报文段，将第一次发生的seq+1生成新的seq，将第二次的seq+1生成ack）（双方进入连接已建立状态）

## 四次挥手（断开连接）

客户端和服务端都可主动向对方发起（下方用客户端主动举例）

1. 客户端 ---> 服务端 （发送时携带FIN=1，ACK=1，表明式TCP连接释放报文段，生成序号seq（等于之前传送过的数据的最后一个字节序号+1），生成确认号ack（之前收到数据的最后一个字节的序号+1）将它们都发送给服务端）（客户端进入wait1阶段）
2. 服务端 ---> 客户端 （设置ACK=1普通确认报文段，生成序号seq（等于之前服务器传送过的数据的最后一个字节序号+1 等于上面第一次的的ack），生成确认号ack等于上面的seq+1，全发送给客户端（服务器进入关闭等待状态，TCP进入半关闭状态，客户端已无数据可发，但服务端如果还有未完成请求或别的直到把这些处理完成才会进行下一次挥手，此时响应客户端会进入wait2状态等待这些任务完成））
3. 服务端 --> 客户端 （此时服务端已将所有任务处理完毕，设置FIN=1,ACK=1表明是TCP释放连接报文段，生成新的seq，生成确认号ack等于第一次的seq+1，（此时服务端进入最后确认状态））
4. 客户端 --> 服务端 （接收到第三次挥手后,客户端进入超时等待状态2MSL一般持续1-4分钟，将发起最后一次挥手，ACK=1普通确认报文，生成seq等于第一次的seq+1，生成ack等于第三次seq+1，服务端接收到后进入关闭状态，客户端等待时间结束后会强制关闭）（因为最后一次挥手是意外导致ACK丢失，则服务端会重新去发送断开的请求来保证连接的可靠性，为了避免无尽的重复请求就强制在一定时间后关闭，而且在这段时间所有的旧报文段都会在网络中彻底消失，下一次连接就不会出现旧连接中的报文段）

## 浏览器输入url发送了什么

### 认识url

举例：http:/www.server.com/diir1/fie1.html

http 是访问协议

www.server.com 是域名（服务器名称）

dir1 请求文件（资源）的路径名

file1.html 文件名

### DNS查询

查询顺序

浏览器自身DNS > 操作系统DNS > 本地hosts文件 > 向域名服务器发送请求

该请求先发送到本地DNS服务（1.根域名服务器 . 2.顶级域名服务器 com）> 权威域名服务器

命令: `dig +trace`
如:`dig +trace baidu.com`查询百度的

拿到 `ip` 后就可以开始请求了

### 渲染（请求结束拿到资源后）

HTML 解析器将超文本和标签解析为DOM树 

渲染引擎将 CSS 转换为浏览器可以理解的 styleSheets，计算出 DOM 节点样式 (有的属性不好转换如 em单位，颜色字母（如blue，yellow），font-weight:blod，可以提前处理 em > px,颜色换成 rgba 形式，font-weight：700 等)

解析 JavaScript （V8引擎谷歌浏览器）

![V8解析](/image/v8.png "V8解析流程图")

拓展：计算机组成原理

软件+硬件（基于冯诺依曼架构体系）

## CDN

在 DNS 解析到权威域名服务器这层时 变成了 智能DNS 它会自己找最近的节点

负载均衡：当某个节点服务器负载很高时会吧新的请求给最近的其他节点进行处理


## http2

最新的超文本传输协议，目前还未全面采用，更高的效率，性能，安全。
可以在浏览器网络调试工具看到网站使用的是什么协议

特点：

1. 多路复用（Multiplexing），在单个 TCP 连接上同时发送多个请求和响应，可以避免建立多个连接，减少网络延迟，提高效率

2. 二进制分帧（Binary Framing，在应用层（HTPP2）和传输层（TCP or UDP）之间增加的二进制分帧层，将请求和响应拆分为多个帧（frames）。这种二进制格式的设计是的协议更加高效并且容易解析和处理。
 - 数据帧（Data Frame）：用于传输请求和响应的实际数据。
 - 头部帧（Headers Frame）：包含请求或响应的头部信息。
 - 优先级帧（Priority Frame）：用于指定请求的优先级。
 - 设置帧（Settings Frame）：用于传输通信参数的设置。
 - 推送帧（Push Promise Frame）：用于服务器主动推送资源。
 - PING 帧（PING Frame）：用于检测连接的活跃性。
 - 重置帧（RST_STREAM Frame）：用于重置数据流或通知错误。

3. 头部压缩（Header Compression）：HTTP/2 使用首部表（Header Table）和动态压缩算法来减少头部的大小。这减少了每个请求和响应的开销，提高了传输效率。
- 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销


### nodejs 实现 http2

截止2024-4-2日 目前没有浏览器支持http请求访问http2,所以要用https,需要tls证书

如何生成 tls 证书：
使用 `openssl` 生成 (步骤参考如下)
1. 生成私钥 
```sh
openssl genrsa -out server.key 1024
```
2. 生成证书请求文件(用完可以删掉也可以保留)
```sh
openssl req -new -key server.key -out server.csr
```
3. 生成证书
```sh
openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650
```

index.js代码（nodemon index.js 启动服务）：

```js
import http2 from 'node:http2'
import fs from 'node:fs'

// 创建服务
// https 可以访问 http2 否则浏览器不支持访问
const server = http2.createSecureServer({
    // 证书文件 （必要否则会是 http ）
    key:fs.readFileSync('./server.key'),
    cert:fs.readFileSync('./server.crt')
})

// http2 使用的是流的方法传输的
// on方法监听 stream （stream 也就是流）
server.on('stream',(stream,headers)=>{
    // respond方法返回响应头
    stream.respond({
        'content-type':'text/html;charset=utf-8',
        // 特殊头部需要加 :
        ':status':200,
    })
    // 错误提示
    stream.on('error', (err) => {
        console.log(err)
    })
    // end方法给前端返回数据
    stream.end('<h1>我是HTTP2</h1>')
})

server.listen(9999,()=>{
    console.log('running in https://localhost:9999');
})
```